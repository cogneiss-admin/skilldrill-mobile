import { useState, useEffect, useCallback, useRef } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { apiService } from '../services/api';
import { useToast } from './useToast';

// Assessment session storage keys
const ASSESSMENT_SESSION_KEY = 'assessment_session_data';
const ASSESSMENT_RESPONSES_KEY = 'assessment_responses_data';

export interface AssessmentSession {
  sessionId: string;
  currentAssessment: any;
  currentScenario: number;
  timeRemaining: number;
  startTime: number;
  timestamp: number;
}

export interface AssessmentResponse {
  [promptId: string]: string;
}

export const useAssessmentSession = () => {
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [currentAssessment, setCurrentAssessment] = useState<any>(null);
  const [currentScenario, setCurrentScenario] = useState(0);
  const [userResponse, setUserResponse] = useState('');
  const [responses, setResponses] = useState<AssessmentResponse>({});
  const [timeRemaining, setTimeRemaining] = useState(3600); // 60 minutes
  const [startTime, setStartTime] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSessionActive, setIsSessionActive] = useState(false);

  const { showToast } = useToast();
  
  // Refs for cleanup
  const timeIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const sessionTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Cleanup function to prevent memory leaks
  const cleanup = useCallback(() => {
    if (timeIntervalRef.current) {
      clearInterval(timeIntervalRef.current);
      timeIntervalRef.current = null;
    }
    if (sessionTimeoutRef.current) {
      clearTimeout(sessionTimeoutRef.current);
      sessionTimeoutRef.current = null;
    }
  }, []);

  // Load saved session data
  const loadSavedSession = useCallback(async (): Promise<boolean> => {
    try {
      const savedSession = await AsyncStorage.getItem(ASSESSMENT_SESSION_KEY);
      const savedResponses = await AsyncStorage.getItem(ASSESSMENT_RESPONSES_KEY);
      
      if (savedSession) {
        const sessionData: AssessmentSession = JSON.parse(savedSession);
        const now = Date.now();
        const sessionAge = now - sessionData.timestamp;
        
        // Check if session is still valid (24 hours)
        if (sessionAge < 24 * 60 * 60 * 1000) {
          console.log('🔄 Restoring saved session:', sessionData);
          setSessionId(sessionData.sessionId);
          setCurrentAssessment(sessionData.currentAssessment);
          setCurrentScenario(sessionData.currentScenario);
          setTimeRemaining(sessionData.timeRemaining);
          setStartTime(sessionData.startTime);
          setIsSessionActive(true);
          
          if (savedResponses) {
            setResponses(JSON.parse(savedResponses));
          }
          
          return true;
        } else {
          // Clear expired session
          await AsyncStorage.multiRemove([ASSESSMENT_SESSION_KEY, ASSESSMENT_RESPONSES_KEY]);
        }
      }
      return false;
    } catch (error) {
      console.error('❌ Error loading saved session:', error);
      return false;
    }
  }, []);

  // Save session data
  const saveSessionData = useCallback(async () => {
    try {
      // Validate required data before saving
      if (!sessionId || !startTime) {
        console.log('⚠️ Cannot save session data: missing sessionId or startTime');
        return;
      }

      const sessionData: AssessmentSession = {
        sessionId: sessionId,
        currentAssessment,
        currentScenario,
        timeRemaining: timeRemaining || 3600,
        startTime: startTime,
        timestamp: Date.now()
      };
      
      await AsyncStorage.setItem(ASSESSMENT_SESSION_KEY, JSON.stringify(sessionData));
      await AsyncStorage.setItem(ASSESSMENT_RESPONSES_KEY, JSON.stringify(responses));
    } catch (error) {
      console.error('❌ Error saving session data:', error);
    }
  }, [sessionId, currentAssessment, currentScenario, timeRemaining, startTime, responses]);

  // Clear session data
  const clearSessionData = useCallback(async () => {
    try {
      await AsyncStorage.multiRemove([ASSESSMENT_SESSION_KEY, ASSESSMENT_RESPONSES_KEY]);
      setIsSessionActive(false);
    } catch (error) {
      console.error('❌ Error clearing session data:', error);
    }
  }, []);

  // Start new adaptive assessment session
  const startAdaptiveSession = useCallback(async (skillId: string) => {
    try {
      setLoading(true);
      setError(null);

      console.log('🎯 Starting adaptive assessment session for skill:', skillId);

      const response = await apiService.startAdaptiveAssessment(skillId);

      if (response.success) {
        console.log('✅ Adaptive assessment session started:', response.data);
        setSessionId(response.data.sessionId);
        setCurrentAssessment(response.data.question); // First question
        setCurrentScenario(0);
        setResponses({});
        setStartTime(Date.now());
        setTimeRemaining(3600); // 60 minutes in seconds
        setIsSessionActive(true);

        // Save session data after a short delay to ensure state is set
        setTimeout(() => {
          saveSessionData();
        }, 100);

        return response.data;
      } else {
        throw new Error(response.message || 'Failed to start adaptive assessment session');
      }
    } catch (error: any) {
      console.error('❌ Assessment initialization error:', error);
      setError(error.message || 'Failed to initialize assessment');
      throw error;
    } finally {
      setLoading(false);
    }
  }, [saveSessionData]);

  // Process answer and get next question (Adaptive)
  const processAdaptiveAnswer = useCallback(async (userAnswer: string) => {
    if (!sessionId) {
      throw new Error('No active session');
    }

    try {
      setLoading(true);

      const response = await apiService.processAdaptiveAnswer(sessionId, userAnswer);

      if (response.success) {
        if (response.data.completed) {
          // Assessment is complete
          await clearSessionData();
          return { completed: true, results: response.data };
        } else {
          // Continue with next question
          setCurrentAssessment(response.data.question);
          setCurrentScenario(response.data.progress.currentQuestion - 1);
          return response.data;
        }
      } else {
        throw new Error(response.message || 'Failed to process answer');
      }
    } catch (error: any) {
      console.error('❌ Error processing adaptive answer:', error);
      setError(error.message || 'Failed to process answer');
      throw error;
    } finally {
      setLoading(false);
    }
  }, [sessionId, clearSessionData]);

  // Load current assessment for session
  const loadCurrentAssessment = useCallback(async () => {
    if (!sessionId) return;

    try {
      const response = await apiService.get(`/assessment/session/${sessionId}/current`);
      
      if (response.success) {
        if (response.data.completed) {
          // All assessments completed
          await clearSessionData();
          showToast('success', 'Assessment Complete', 'All assessments have been completed!');
          return { completed: true };
        }
        
        setCurrentAssessment(response.data.assessment);
        setCurrentScenario(0);
        setResponses({});
        await saveSessionData();
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to load current assessment');
      }
    } catch (error: any) {
      console.error('❌ Load assessment error:', error);
      setError(error.message || 'Failed to load assessment');
      throw error;
    }
  }, [sessionId, saveSessionData, clearSessionData, showToast]);

  // Submit assessment responses
  const submitResponses = useCallback(async () => {
    if (!sessionId || !currentAssessment) {
      throw new Error('No active assessment session');
    }

    try {
      setLoading(true);

      // Save final response
      const currentQ = currentAssessment.template?.prompts?.[currentScenario];
      if (currentQ && userResponse.trim()) {
        setResponses(prev => ({
          ...prev,
          [currentQ.id]: userResponse
        }));
      }

      // Format responses for bulk submission
      const allResponses = { ...responses };
      if (currentQ && userResponse.trim()) {
        allResponses[currentQ.id] = userResponse;
      }

      const formattedResponses = Object.entries(allResponses).map(([promptId, response]) => ({
        promptId,
        response: typeof response === 'string' ? response : response.toString()
      }));

      console.log('📊 Submitting responses:', formattedResponses);

      // Submit current assessment responses
      const response = await apiService.post('/assessment/response/bulk', {
        assessmentId: currentAssessment.id,
        responses: formattedResponses
      });

      if (response.success) {
        console.log('✅ Assessment responses submitted');
        
        // Move to next assessment in session
        const nextResponse = await apiService.post(`/assessment/session/${sessionId}/next`);
        
        if (nextResponse.success) {
          if (nextResponse.data.completed) {
            // All assessments completed
            await clearSessionData();
            showToast('success', 'Assessment Complete', 'All assessments have been completed!');
            return { completed: true };
          } else {
            // Load next assessment
            setCurrentAssessment(nextResponse.data.assessment);
            setCurrentScenario(0);
            setResponses({});
            setUserResponse('');
            await saveSessionData();
            return nextResponse.data;
          }
        } else {
          throw new Error(nextResponse.message || 'Failed to continue to next assessment');
        }
      } else {
        throw new Error(response.message || 'Failed to submit assessment responses');
      }
    } catch (error: any) {
      console.error('❌ Assessment submission error:', error);
      setError(error.message || 'Failed to submit assessment');
      throw error;
    } finally {
      setLoading(false);
    }
  }, [sessionId, currentAssessment, currentScenario, userResponse, responses, saveSessionData, clearSessionData, showToast]);

  // Navigate to next scenario
  const nextScenario = useCallback(() => {
    if (!currentAssessment) return;

    const currentQ = currentAssessment.template?.prompts?.[currentScenario];
    if (!currentQ) return;

    // Save current response
    if (userResponse.trim()) {
      setResponses(prev => ({
        ...prev,
        [currentQ.id]: userResponse
      }));
    }

    if (currentScenario < (currentAssessment.template?.prompts?.length || 0) - 1) {
      setCurrentScenario(prev => prev + 1);
      const nextQ = currentAssessment.template?.prompts?.[currentScenario + 1];
      setUserResponse(responses[nextQ?.id] || '');
    }
  }, [currentAssessment, currentScenario, userResponse, responses]);

  // Navigate to previous scenario
  const previousScenario = useCallback(() => {
    if (currentScenario > 0) {
      const currentQ = currentAssessment.template?.prompts?.[currentScenario];
      if (currentQ && userResponse.trim()) {
        setResponses(prev => ({
          ...prev,
          [currentQ.id]: userResponse
        }));
      }
      
      setCurrentScenario(prev => prev - 1);
      const prevQ = currentAssessment.template?.prompts?.[currentScenario - 1];
      setUserResponse(responses[prevQ?.id] || '');
    }
  }, [currentScenario, currentAssessment, userResponse, responses]);

  // Update user response
  const updateUserResponse = useCallback((response: string) => {
    setUserResponse(response);
  }, []);

  // Timer management
  useEffect(() => {
    if (isSessionActive && startTime && timeRemaining > 0) {
      timeIntervalRef.current = setInterval(() => {
        setTimeRemaining(prev => {
          // Handle invalid values
          if (!prev || isNaN(prev) || !isFinite(prev) || prev <= 0) {
            return 0;
          }
          
          const newTime = prev - 1;
          if (newTime <= 0) {
            return 0;
          }
          return newTime;
        });
      }, 1000);

      return () => {
        if (timeIntervalRef.current) {
          clearInterval(timeIntervalRef.current);
          timeIntervalRef.current = null;
        }
      };
    }
  }, [isSessionActive, startTime, timeRemaining]);

  // Auto-save session data
  useEffect(() => {
    if (sessionId && isSessionActive) {
      sessionTimeoutRef.current = setTimeout(() => {
        saveSessionData();
      }, 30000); // Save every 30 seconds

      return () => {
        if (sessionTimeoutRef.current) {
          clearTimeout(sessionTimeoutRef.current);
        }
      };
    }
  }, [sessionId, isSessionActive, saveSessionData]);

  // Cleanup on unmount
  useEffect(() => {
    return cleanup;
  }, [cleanup]);

  // Format time display
  const formatTime = useCallback((seconds: number) => {
    // Handle invalid values
    if (!seconds || isNaN(seconds) || !isFinite(seconds) || seconds < 0) {
      return "00:00";
    }
    
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }, []);

  return {
    // State
    sessionId,
    currentAssessment,
    currentScenario,
    userResponse,
    responses,
    timeRemaining,
    loading,
    error,
    isSessionActive,

    // Actions - Adaptive Only
    startAdaptiveSession,
    processAdaptiveAnswer,
    clearSessionData,

    // Utilities
    setError
  };
};
